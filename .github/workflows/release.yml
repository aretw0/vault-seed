# .github/workflows/release.yml
name: Publicar Release

# Este workflow √© executado automaticamente quando uma nova tag (ex: v1.0.0) √© criada e enviada para o reposit√≥rio.
# Ele automatiza a cria√ß√£o de releases no GitHub, extraindo as notas do CHANGELOG.md.
# Voc√™ tamb√©m pode execut√°-lo manualmente atrav√©s da aba 'Actions' no GitHub.

on:
  push:
    branches:
      - main # Executa quando mudan√ßas s√£o enviadas para a branch main
  workflow_dispatch: # Permite execu√ß√£o manual atrav√©s da interface do GitHub Actions

permissions:
  contents: write # Permite que o GITHUB_TOKEN crie e edite releases e outros conte√∫dos do reposit√≥rio.

jobs:
  create-release:
    runs-on: ubuntu-latest
    steps:
      - name: üõéÔ∏è Checkout do C√≥digo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Necess√°rio para que standard-version possa analisar o hist√≥rico completo

      - name: üè∑Ô∏è Verificar Tag no Commit
        id: check_tag
        run: |
          TAG=$(git describe --tags --exact-match ${{ github.sha }} 2>/dev/null || echo "")
          if [ -z "$TAG" ]; then
            echo "::notice::Nenhuma tag encontrada no commit atual. Pulando a cria√ß√£o da release."
            echo "skip_release=true" >> $GITHUB_OUTPUT
          else
            echo "::notice::Tag '${TAG}' encontrada no commit atual. Prosseguindo com a release."
            echo "skip_release=false" >> $GITHUB_OUTPUT
          fi

      # Os passos seguintes s√≥ ser√£o executados se uma tag for encontrada no commit atual.
      # Isso garante que releases s√≥ sejam criadas para commits tagueados na branch main.
      - name: ‚öôÔ∏è Configurar Node.js
        if: steps.check_tag.outputs.skip_release == 'false'
        uses: actions/setup-node@v4
        with:
          node-version: '20' # Use a vers√£o do Node.js que seu projeto utiliza

      - name: Cache Node.js modules
        id: cache-npm
        if: steps.check_tag.outputs.skip_release == 'false'
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: üì¶ Instalar Depend√™ncias
        if: steps.check_tag.outputs.skip_release == 'false' # S√≥ executa se uma tag for encontrada
        run: npm install # Instala as depend√™ncias do package.json, incluindo standard-version

      - name: üõ°Ô∏è Verificar Commits para Changelog
        if: steps.check_tag.outputs.skip_release == 'false' # S√≥ executa se uma tag for encontrada
        run: |
          CURRENT_TAG_REF=${{ github.ref }} # e.g., refs/tags/v0.2.0
          CURRENT_TAG_NAME=${{ github.ref_name }} # e.g., v0.2.0

          # Get the commit hash of the current tag
          CURRENT_TAG_COMMIT=$(git rev-list -n 1 $CURRENT_TAG_REF)

          # Find the previous *clean* tag name
          # This gets all tags, sorts them by version, and picks the second one (the one before CURRENT_TAG_NAME)
          # Find the previous *actual* tag name
          # This gets the commit hash of the tag immediately preceding the current tag
          PREVIOUS_TAG_COMMIT_HASH=$(git rev-list --tags --max-count=1 --skip=1 ${{ github.sha }})
          PREVIOUS_TAG_NAME=$(git describe --tags --abbrev=0 $PREVIOUS_TAG_COMMIT_HASH 2>/dev/null || echo "")

          echo "::debug::CURRENT_TAG_REF: $CURRENT_TAG_REF"

          if [ -z "$PREVIOUS_TAG_NAME" ]; then
            echo "::warning::Nenhuma tag anterior encontrada. Verificando commits desde o in√≠cio do hist√≥rico at√© a tag atual."
            COMMITS_FOR_CHANGELOG=$(git log $CURRENT_TAG_COMMIT --pretty=format:"%s")
          else
            echo "::debug::√öltima tag anterior encontrada: $PREVIOUS_TAG_NAME"
            COMMITS_FOR_CHANGELOG=$(git log $PREVIOUS_TAG_NAME..$CURRENT_TAG_COMMIT --pretty=format:"%s")
          fi

          echo "::debug::Commits que justificam esta release ($PREVIOUS_TAG_NAME..$CURRENT_TAG_NAME):"
          echo "$COMMITS_FOR_CHANGELOG"

          if echo "$COMMITS_FOR_CHANGELOG" | grep -Eq "^(feat|fix|refactor):|BREAKING CHANGE:"; then
            echo "::notice::Commits relevantes para o changelog encontrados. Prosseguindo com a release."
          else
            echo "::error::Nenhum commit do tipo 'feat', 'fix', 'refactor' ou 'BREAKING CHANGE' encontrado para justificar esta release."
            echo "::error::N√£o ser√° poss√≠vel gerar uma release com conte√∫do vazio no changelog."
            echo "::error::Por favor, adicione um commit relevante e tente novamente."
            exit 1
          fi

      - name: üìù Obter Notas de Release
        if: steps.check_tag.outputs.skip_release == 'false' # S√≥ executa se uma tag for encontrada
        id: get_release_notes
        run: |
          # Extrai as notas de release do CHANGELOG.md para a tag atual
          VERSION_TAG=$(echo ${{ github.ref_name }} | sed 's/v//')
          RELEASE_NOTES=$(node scripts/get_release_notes.js "$VERSION_TAG")

          # Garante que as notas n√£o estejam vazias
          if [ -z "$RELEASE_NOTES" ]; then
            echo "::error::N√£o foi poss√≠vel extrair as notas de release para a vers√£o ${VERSION_TAG} do CHANGELOG.md."
            exit 1
          fi

          echo "release_notes<<EOF" >> $GITHUB_OUTPUT
          echo "$RELEASE_NOTES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: üöÄ Criar GitHub Release
        if: steps.check_tag.outputs.skip_release == 'false' # S√≥ executa se uma tag for encontrada
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.ref }}
          name: ${{ github.ref_name }}
          body: ${{ steps.get_release_notes.outputs.release_notes }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # GITHUB_TOKEN √© fornecido automaticamente pelo GitHub
